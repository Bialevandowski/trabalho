import random
import threading
import time

class MazeGenerator:
    _instance = None
    def __new__(cls, largura=11, altura=11):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.largura = largura
            cls._instance.altura = altura
        return cls._instance
    def gerar_mapa(self, dificuldade=0):
        w = self.largura if self.largura % 2 == 1 else self.largura + 1
        h = self.altura if self.altura % 2 == 1 else self.altura + 1
        maze = [["#" for _ in range(w)] for _ in range(h)]
        def carve(cx, cy):
            dirs = [(0, -2), (0, 2), (-2, 0), (2, 0)]
            random.shuffle(dirs)
            for dx, dy in dirs:
                nx, ny = cx + dx, cy + dy
                if 1 <= nx < h - 1 and 1 <= ny < w - 1 and maze[nx][ny] == "#":
                    maze[nx][ny] = " "
                    maze[cx + dx // 2][cy + dy // 2] = " "
                    carve(nx, ny)
        maze[1][1] = " "
        carve(1, 1)
        entrada = (1, 1)
        saida = (h - 2, w - 2)
        maze[entrada[0]][entrada[1]] = "E"
        maze[saida[0]][saida[1]] = "X"
        added_walls_pct = min(0.12 + dificuldade * 0.06, 0.5)
        candidates = [(i, j) for i in range(1, h - 1) for j in range(1, w - 1)
                      if maze[i][j] == " " and (i, j) not in (entrada, saida)]
        random.shuffle(candidates)
        to_add = int(len(candidates) * added_walls_pct)
        for (i, j) in candidates[:to_add]:
            wall_count = sum(1 for di, dj in [(-1,0),(1,0),(0,-1),(0,1)] if maze[i+di][j+dj] == "#")
            if wall_count >= 2:
                maze[i][j] = "#"
        return maze

class GameTimer:
    def __init__(self):
        self._start_time = None
        self._elapsed = 0.0
        self._running = False
        self._lock = threading.Lock()
        self._thread = None
    def _run(self):
        last = time.time()
        while self._running:
            time.sleep(0.2)
            now = time.time()
            with self._lock:
                self._elapsed += now - last
            last = now
    def start(self):
        if not self._running:
            with self._lock:
                self._start_time = time.time()
                self._elapsed = 0.0
                self._running = True
            self._thread = threading.Thread(target=self._run, daemon=True)
            self._thread.start()
    def stop(self):
        if self._running:
            self._running = False
            if self._thread:
                self._thread.join(timeout=0.5)
    def elapsed(self):
        with self._lock:
            return self._elapsed

class LabirintoGame:
    def __init__(self, mapas=3, largura=21, altura=21):
        self.total_mapas = max(1, mapas)
        self.current_map = 0
        self.largura = largura
        self.altura = altura
        self.generator = MazeGenerator(largura=self.largura, altura=self.altura)
        self.player_pos = (1, 1)
        self.mapa = []
        self.timer = GameTimer()
        self.partida_começou = False
    def exibir_mapa(self):
        display = []
        for i, row in enumerate(self.mapa):
            row_chars = []
            for j, c in enumerate(row):
                if (i, j) == self.player_pos:
                    row_chars.append("P")
                else:
                    row_chars.append(c)
            display.append(" ".join(row_chars))
        tempo = self.timer.elapsed() if self.partida_começou else 0.0
        print(f"\nMapa {self.current_map}/{self.total_mapas}   Tempo: {tempo:.1f}s")
        print("\n".join(display))
        print()
    def iniciar_mapa(self, dificuldade):
        self.mapa = self.generator.gerar_mapa(dificuldade=dificuldade)
        for i, row in enumerate(self.mapa):
            for j, c in enumerate(row):
                if c == "E":
                    self.player_pos = (i, j)
                    return
    def mover(self, direção):
        i, j = self.player_pos
        direção = direção.upper()
        if direção == "W": ni, nj = i - 1, j
        elif direção == "S": ni, nj = i + 1, j
        elif direção == "A": ni, nj = i, j - 1
        elif direção == "D": ni, nj = i, j + 1
        else: return False, "Comando inválido"
        if not (0 <= ni < len(self.mapa) and 0 <= nj < len(self.mapa[0])):
            return False, "Limite"
        if self.mapa[ni][nj] == "#":
            return False, "Parede"
        self.player_pos = (ni, nj)
        return True, "Movimentou"
    def check_saida(self):
        i, j = self.player_pos
        return self.mapa[i][j] == "X"
    def jogar(self):
        print("=== JOGO DO LABIRINTO ===")
        print("Use W, A, S, D. Chegue em 'X'.")
        self.timer.start()
        self.partida_começou = True
        while self.current_map < self.total_mapas:
            self.current_map += 1
            dificuldade = self.current_map - 1
            self.iniciar_mapa(dificuldade=dificuldade)
            while True:
                self.exibir_mapa()
                cmd = input("Movimento (W/A/S/D) ou Q: ").strip().upper()
                if cmd == "Q":
                    print("Saiu do jogo.")
                    self.timer.stop()
                    return
                ok, msg = self.mover(cmd)
                if not ok: print(msg)
                if self.check_saida():
                    print("Saída encontrada!\n")
                    time.sleep(0.5)
                    break
        self.timer.stop()
        tempo_total = self.timer.elapsed()
        print("Parabéns, você venceu todos os mapas!")
        print(f"Tempo total: {tempo_total:.2f} segundos.")

def main():
    jogo = LabirintoGame(mapas=3, largura=21, altura=21)
    jogo.jogar()

if __name__ == "__main__":
    main()
